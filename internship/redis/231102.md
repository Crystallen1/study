## 什么是Redis
Redis - Remote dictionary server 名字中可以看到他的一些特点，首先他是可以远程访问的，客户端可以在不同的机器上运行，并通过*TCP*连接到运行Redis服务器的机器。其次，他是使用dictionary，也就是映射来储存数据的，类似于hashmap。
除此之外Redis还是很多其他的特性
+ 高性能 ：在Redis中，数据都是储存在服务器的RAM中，因此读写速度会很快
+ 丰富的数据类型：支持的数据结构非常多
+ 持久性：通过RDB（快照）和AOF（追加文件）方式可以将内存中的数据保存到磁盘中，保证了数据的安全性。
+ 支持事务：Redis通过MULTI、EXEC、WATCH等命令提供了事务功能。
+ 支持Lua脚本： 可以通过Lua脚本在服务器端执行复杂的操作。
+ 高可用和分布式：支持主从复制，以及通过Sentinel和Cluster提供高可用性和数据分片。
+ 发布/订阅能力：支持发布/订阅消息模式，适用于构建消息系统。

### RDB（快照）
RDB全称Redis Database，就是一个定时生成的数据库副本二进制文件。他保存着数据库中的全部数据，但是是静态的，无法增删改查。

#### 优点
+ RDB可以最大化Redis性能：由于Redis父进程仅在需要进行保存操作时才会创建一个子进程来写入磁盘，所以它的性能不会被持久化操作影响。
+ RDB是一个更紧凑的文件，保存在磁盘上的数据可以更快地重新加载到Redis。
####  缺点
+ 根据配置和数据变化的频率，如果发生故障，你可能会丢失最后几分钟的数据。
+ 由于RDB需要创建子进程来进行保存，如果数据集很大，会有一定的性能影响。
### AOF(追加文件)
AOF全程Append-Only File，不同于RBD记录某一时刻数据库的快照，AOF记录的是数据被修改的操作，他会作为追加文件保存在一个日志的尾部。（重返未来1999中的自动战斗），可以通过一个RDB和一个从这个RDB开始AOF恢复数据

#### 优点
+ AOF可以提供更好的数据耐久性：根据同步策略的不同，AOF可以减少数据丢失的可能性。
+ AOF文件是一个只追加的日志文件，即使在日志过程中遇到异常，也可以很容易地进行修复。
+ AOF具有更好的可读性，你可以用文本编辑器打开并阅读或修改它。
####  缺点
+ 对于相同数量的数据变更，AOF文件通常比RDB文件大。
+ 根据所选择的同步策略，AOF可能会比RDB慢一些。

##Redis的事务
Redis的事务提供了一种将多个命令打包，然后一次性、顺序地执行的机制。
+ MULTI 开始一个事务
+ EXEC 执行所有队列中的命令
+ DISCARD 取消一个事务
+ 原子性： 要么全部执行，要么有错误一个不执行。但是因为Redis没有回滚功能（在MUTIL的时候创建一个快照，但是这样性能就受到影响），因此不同于传统数据库的原子性，Redis的事务如果运行到错误的部分还是会全部执行完剩余的指令（2.6.5版本前），而新版本中遇到错误的部分就不会执行后续指令，但也不会回滚。
+ 隔离性（Isolation）：即使事务中的命令被逐个执行，也保证了一个事务中的命令不会被其他客户端发送的命令所中断。
+ 不持久性（Non-persistence）：如果在事务执行过程中服务器停机，即使是使用了持久化，事务中的命令也可能不会全部持久化到磁盘。

### 悲观锁和乐观锁
悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）是两种常见的并发控制策略
#### 悲观锁
*定义：*
悲观锁的核心思想是假设冲突是常态，因此在数据处理过程中会主动防止其他事务或操作进行干扰。
*使用场景：*
当数据被频繁修改，且并发事务或操作数量较多时，通常使用悲观锁。
*工作原理：*
加锁：在读取数据之前，事务对数据进行加锁，防止其他所有修改或加锁请求。
处理：事务处理数据（读取、修改）。
解锁：事务完成后释放锁，允许其他事务访问数据。
*问题：*
使用悲观锁可能会导致死锁问题和系统性能问题，因为在锁定期间，其他事务必须等待，这降低了系统的吞吐量。
#### 死锁
是指在多任务环境中，由于两个或多个运行单元（例如线程、进程或事务）互相等待对方持有的资源而永远地阻塞自己的一种情况。
如：T1和T2两个进程并发进行，T1获取了表a的锁但同时也要要读取表b中的内容，T2获得了表b的锁但要修改表a的内容。这样两个进程就永远进行不下去。
*Redis 事务本身不支持悲观锁。需要外部逻辑来保证。*
#### 乐观锁
*定义：*
乐观锁基于这样的假设：冲突发生的情况较少，所以不用在数据处理过程中主动加锁防冲突。
*使用场景：*
在并发事务少或读多写少的场景下，乐观锁是一个更好的选择，因为它可以避免加锁的开销。
*工作原理：*
在每次读写操作后记录数据库的版本号（快照），并在每次读写前检查版本号是否发生变化（如果变化说明数据库被别的事务修改过）。如果版本号一致，则进行更新，并增加版本号。如果版本号不一致，则说明在读取数据和更新数据之间，数据已经被其他事务修改过，这时通常会重试或放弃操作。

*在Redis中，乐观锁主要通过WATCH命令来实现。*
1.WATCH命令用于“监视”一个或多个键。
2.执行一系列命令来准备数据更新。
3.在执行MULTI之后的EXEC命令前，如果监视的键没有被其他客户端修改过，那么事务正常执行。
4.如果在执行MULTI之后执行EXEC之前，有其他客户端修改了WATCH监视的键，那么事务会被取消，EXEC返回nil。

##发布/订阅
Redis 的发布/订阅（pub/sub）模型是一种消息通信模式
简单说，就是a订阅了某个通道，那么b在这个通道发布的消息就会被a接受。

## 内存淘汰机制
Redis 的内存淘汰机制是指当内存使用达到一定阈值时，Redis 会按照一定的策略移除一些键，从而为新的写入操作腾出空间。
1.noeviction（不淘汰）: 达到内存限制时，对写入操作返回错误，但允许读操作和删除操作。
2.allkeys-lru（所有键最少使用淘汰）: 从所有键中，淘汰最近最少使用的键（LRU）。
3.volatile-lru（设置了过期时间的键最少使用淘汰）: 从设置了过期时间的键中，淘汰最近最少使用的键（LRU）。
4.allkeys-random（所有键随机淘汰）: 从所有键中随机淘汰一些键。
5.volatile-random（设置了过期时间的键随机淘汰）: 从设置了过期时间的键中随机淘汰一些键。
6.volatile-ttl（根据TTL值淘汰）: 从设置了过期时间的键中，优先淘汰将要过期的键。
7.volatile-lfu（设置了过期时间的键最不经常使用淘汰）: 从设置了过期时间的键中，淘汰最不经常使用的键（LFU）。
8.allkeys-lfu（所有键最不经常使用淘汰）: 从所有键中，淘汰最不经常使用的键（LFU）。

## 主从复制
Redis的主从复制（Master-Slave replication）是一种数据复制和冗余的机制，用于创建一个或多个Redis服务器的精确副本。主从复制的主要目的是提高数据的可用性和冗余，以及在分布式环境中扩展读操作。