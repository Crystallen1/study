## 为什么重写 equals 还要重写 hashCode？
equals是用来比较两个对象的函数，如果两个对象是相等的（我们逻辑上规定的相等），那么equals会返回true。
而hashCode是用来返回一个对象的哈希值，它是一个整数值。而我们都知道相同的对象理应获得相同的哈希值。
那么如果我们重写了equals，就相当于改变了这个类的相等的规则，那么原先不相等的对象可能就相等了，原先相等的对象可能就不相等了。那么就会影响哈希值中相同的对象理应获得相同的哈希值这一规则。因此我们要重写hashCode，使满足这条规则。
## == 和 equals 比较的区别
equals是java中写在object类里面的方法，因此如果是比较这两个东西，显然是比较对象使用这两个东西的区别。
对于两个对象，只有在他们引用的东西相同的时候才会使得==为true，例如b是a的拷贝引用，那么a==b
而对于equals则是，我们规定在这个类上的规则，让两个对象逻辑相等的规则。
## final 关键字的作用
用于类：阻止类被继承。
用于方法：阻止方法被重写。
用于变量：变量被赋值后，其值不能被修改（基本数据类型的值不变，引用类型的引用不变，但对象内容可变）。
## ArrayList 和 LinkedList 的区别
ArrayList 基于动态数组实现，支持快速的随机访问。但在列表中间插入和删除操作较慢，因为这可能需要移动元素。
LinkedList 基于双向链表实现，不支持快速随机访问。但在列表中间的插入和删除操作更快，因为这不需要移动元素，只需要更改指针。
## 接口和抽象类的区别
+ 接口和抽象类都是java中多态的体现
+ 接口更像是一直契约、规定。抽象类更像是代码的共用（基础功能）
+ 在方法方面，java8之后接口中可以有抽象方法、默认方法和静态方法。抽象方法不需要显示表示（abstract可以不写），默认方法可以被子类重写，静态方法不能重写，而且必须由接口命本身调用。在子类中所有的抽象方法必须被实现。在抽象类中，可以有各种方法，但也得有抽象方法，抽象方法必须要写上前缀abstract。
+ 在继承、实现方面，一个子类只能继承一个抽象类，但是可以实现多个接口。
+ 在构造函数方面，抽象类可以有构造函数，而接口没有构造函数。
+ 在字段方面，接口不能有实例字段，可以有静态常量，抽象类就都可以有。

